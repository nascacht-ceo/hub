Scoped Queue Logging for .NET

This library provides a custom ILoggerProvider for .NET that enables capturing logs generated within a specific ILogger scope and routing them to an in-memory queue.

This is invaluable for scenarios like:

- Integration Testing: Asserting that specific log messages (warnings, errors, etc.) were generated by your business logic.
- Live Request Tracing: Capturing all logs for a single API request and streaming them to a client (e.g., via WebSockets) for live debugging.
- Contextual Reporting: Gathering all logs related to a specific background task and attaching them to a final success or failure report.

The core idea is to "tag" a section of code with a special QueueScope object. 
Any `ILogger` calls made from any service while that scope is active will be captured by that scope's queue.

## Core Components

QueueLoggerProvider: The ILoggerProvider that creates QueueLogger instances.
QueueLogger: The ILogger implementation. It checks the IExternalScopeProvider on every Log call. If it finds an active QueueScope, it adds the log message to that scope's queue.
QueueScope: The "magic" object. This is a custom scope that you create. It holds the BlockingCollection<QueueMessage> that logs will be written to.
QueueMessage: The POCO that stores log details (Timestamp, Level, Message, etc.) in the queue.

## Performance & Safety

This provider is designed for high-performance and production safety:

- Non-Blocking Producer: The logger uses BlockingCollection.TryAdd(). If the queue is full (e.g., a slow consumer), it will drop the log message instead of blocking the application thread. This ensures your application's performance is never degraded by a slow log consumer.
- Bounded Memory: The QueueScope uses a BlockingCollection with a fixed capacity (MaxQueueSize). This prevents unbounded memory growth and OutOfMemoryException if a consumer disconnects or is slow to process messages.
- Efficient Consumer: A consumer (like a test or WebSocket) can use Queue.GetConsumingEnumerable() to efficiently wait for new messages with 0% CPU usage.

1. Setup

Register the logger provider in your Program.cs or Startup.cs.

```csharp
// In Program.cs or your DI setup
builder.Services.AddLogging(loggingBuilder =>
{
    loggingBuilder.AddConsole(); // Add other providers
    loggingBuilder.AddQueueLogger(); // Add the custom queue provider
    loggingBuilder.SetMinimumLevel(LogLevel.Trace);
});
```

2. Usage

The pattern is always the same:

- Create a QueueScope instance.
- Get an ILogger (from DI).
- Begin a logger scope, passing in your QueueScope instance.
- Execute your code.
- Read the results from your QueueScope.Queue.

## Use Case A: Integration Testing

This is the most common use case. You can test your services without mocking `ILogger`.

Let's say you have a service:

```csharp
// Your application service
public class MyBusinessService
{
    private readonly ILogger<MyBusinessService> _logger;
    
    public MyBusinessService(ILogger<MyBusinessService> logger)
    {
        _logger = logger;
    }

    public void DoWork()
    {
        _logger.LogInformation("MyBusinessService is doing work.");
        using (_logger.BeginScope("Transaction-{TxId}", 456))
        {
            _logger.LogError("Something bad happened inside the transaction.");
        }
    }
}
```

You can test it like this (using xUnit):

```csharp
[Fact]
public void Logs_FromBusinessService_AreCapturedBy_QueueScope()
{
    // 1. ARRANGE
    var services = new ServiceCollection();
    services.AddLogging(builder => builder.AddQueueLogger());
    services.AddTransient<MyBusinessService>();
    
    var provider = services.BuildServiceProvider();
    
    // Get the logger *and* the service from DI
    var logger = provider.GetRequiredService<ILogger<WebSocketLogCaptureTest>>();
    var businessService = provider.GetRequiredService<MyBusinessService>();

    // Create the "log listener"
    using var logScope = new QueueScope("MyTest-123");

    // 2. ACT
    // Begin the scope and pass in our logScope instance
    using (logger.BeginScope(logScope))
    {
        // Call the service. This service has no idea
        // its logs are being captured.
        businessService.DoWork();
    } // Scope is exited, logging stops

    // 3. ASSERT
    // We can now check the queue
    var capturedLogs = logScope.Queue;

    Assert.Equal(2, capturedLogs.Count);
    
    var errorLog = capturedLogs.First(log => log.LogLevel == LogLevel.Error);
    Assert.Equal("Something bad happened inside the transaction.", errorLog.Message);
}
```

## Use Case B: Live Request Tracing (e.g., WebSockets)

In this scenario, a "consumer" thread needs to read from the queue as items are added.

Producer (e.g., ASP.NET Core Middleware):

```csharp
// A simplified version of a middleware
public async Task InvokeAsync(HttpContext context, ILogger<LogCaptureMiddleware> logger)
{
    // Check for a header, auth, etc.
    if (context.Request.Headers.ContainsKey("X-Trace-Logs"))
    {
        // 1. Create the scope for this request
        await using (var logScope = new QueueScope($"Trace-{context.TraceIdentifier}"))
        {
            // 2. Start the consumer task
            // (e.g., a WebSocket class that takes the queue)
            var webSocketTask = StartWebSocketConsumer(context, logScope.Queue);

            // 3. Begin the logger scope
            using (logger.BeginScope(logScope))
            {
                // 4. Run the rest of the app
                await _next(context);
            } // logScope.Dispose() is called here, which calls
              // logScope.Queue.CompleteAdding(), safely ending the consumer task.

            await webSocketTask;
        }
    }
    else
    {
        await _next(context);
    }
}
```

Consumer (e.g., WebSocket handler):

This code runs on a separate thread and uses `GetConsumingEnumerable()` to efficiently wait for messages.

```csharp
private async Task StartWebSocketConsumer(
    HttpContext context,
    BlockingCollection<QueueMessage> logQueue)
{
    var webSocket = await context.WebSockets.AcceptWebSocketAsync();

    try
    Details: {
        // GetConsumingEnumerable() blocks efficiently (0% CPU)
        // until an item is added to the queue OR CompleteAdding() is called.
        foreach (var logMessage in logQueue.GetConsumingEnumerable())
        {
            var messageJson = System.Text.Json.JsonSerializer.Serialize(logMessage);
            var buffer = System.Text.Encoding.UTF8.GetBytes(messageJson);
            
            await webSocket.SendAsync(
                new ArraySegment<byte>(buffer),
                WebSocketMessageType.Text,
                true,
                CancellationToken.None);
        }
    }
    catch (Exception ex)
    {
        // Handle socket exceptions
    }
    finally
    Details: {
        // The loop finished cleanly
        await webSocket.CloseAsync(
            WebSocketCloseStatus.NormalClosure,
            "Log trace finished.",
            CancellationToken.None);
    }
}
```